### Наш мозг довольно быстро обрабатывает значение такого предложения.

Мы можем предположить:

- Некоторые вещи должны быть правдой: «Вы можете найти правильный ответ в процессе исключения».
- Другие, которые могут иметь правду: «Идеи, которые невероятны, не невозможны!»
- И некоторые утверждения явно противоречат друг другу: «Истина в том, что вы исключили как невозможное».


Обработка естественного языка (НЛП) стала все более сложной за последние несколько лет. Модели машинного обучения 
позволяют отвечать на вопросы, извлекать текст, создавать предложения и решать многие другие сложные задачи. Но 
могут ли машины определять отношения между предложениями, или это все еще остается на усмотрение людей? Если НЛП 
можно применять между предложениями, это может иметь серьезные последствия для проверки фактов, выявления фейковых 
новостей, анализа текста и многого другого.    

### Соревнование:
Если у вас есть два предложения, их можно связать тремя способами: одно может повлечь за собой другое, одно может 
противоречить другому или они могут не быть связаны. Вывод естественного языка (NLI) - популярная задача НЛП, 
которая включает определение того, как связаны пары предложений (состоящих из предпосылки и гипотезы).   

Ваша задача - создать модель NLI, которая присваивает парам посылок и гипотез ярлыки 0, 1 или 2 (соответствующие 
следствию, нейтральности и противоречию). Чтобы было интереснее, обучающий и тестовый набор включает текст на 
пятнадцати разных языках! Вы можете найти более подробную информацию о наборе данных, просмотрев страницу данных.  

Сегодня наиболее распространенные подходы к проблемам NLI включают использование встраиваний и преобразователей, 
таких как BERT. В этом конкурсе мы предоставляем стартовый блокнот, чтобы попробовать свои силы в решении этой 
проблемы, используя мощь блоков тензорной обработки (TPU). TPU - это мощные аппаратные ускорители, 
специализирующиеся на задачах глубокого обучения, включая обработку естественного языка. Kaggle бесплатно 
предоставляет всем пользователям квоту TPU, которую вы можете использовать для изучения этого соревнования. 
Ознакомьтесь с нашей документацией по TPU и плейлистом Kaggle на YouTube для получения дополнительной информации и 
ресурсов. 

### Модель RoBERTa 
 В учебнике для прогнозов используется предварительно обученная модель BERT в сочетании с классификатором. Чтобы
получить лучшие результаты, чем учебник, мы будем использовать более крупную модель с той же архитектурой,
называемой RoBERTa, эта модель использует в основном в 10 раз больше данных и
тренируется больше, чем исходная модель.

Модель RoBERTa основан на BERT и изменяет ключевые гиперпараметры, удаляя цель предварительного обучения в следующем 
предложении и обучая с гораздо более крупными мини-пакетами и скоростями обучения. 

Характеристики модели:

- Эта реализация аналогична BertModel с небольшой настройкой вложений, а также настройкой для предварительно 
обученных моделей Roberta.
- RoBERTa имеет ту же архитектуру, что и BERT, но использует BPE байтового уровня в качестве токенизатора (как GPT-2) 
  и использует другую схему предварительного обучения.
- У RoBERTa нет token_type_ids, указывать какой токен какому сегменту не нужно. Просто разделите свои сегменты токеном 
разделения tokenizer.sep_token(или </s>) 


BERT использует три типа входных данных: идентификаторы слов ввода, маски ввода и идентификаторы типов ввода.

Это позволяет модели знать, что посылка и гипотеза являются отдельными предложениями, а также игнорировать любые 
дополнения от токенизатора. 

Мы добавляем токен [CLS], чтобы обозначить начало входных данных, и токен [SEP], чтобы обозначить разделение между 
предпосылкой и гипотезой. Нам также нужно заполнить все входы одинакового размера. Для получения дополнительной 
информации о входах BERT см .: https://huggingface.co/transformers/model_doc/bert.html#tfbertmodel  

Чтобы подготовить наши идентификаторы токенов, которые мы получили с помощью нашей функции encode_sentence(), 
чтобы они стали входными в BERT, мы сначала объединяем список идентификаторов токенов каждого предложения в столбце 
гипотез и предпосылки (помните, что каждое предложение уже разделено токеном [SEP] в конце, который мы добавили выше) 
в один список и добавьте еще один идентификатор токена в самом начале (идентификатор для токена '[CLS]'), который 
обозначает начало. Однако выходной список encode_sentence () будет иметь разную длину для каждого предложения из 
нашего набора данных, что означает, что мы не можем просто построить красивую таблицу из всех этих объединенных 
списков, чтобы передать их BERT. Вместо этого нам придется добавлять нули в конец каждого списка идентификаторов, 
пока он не достигнет длины самого длинного списка в наборе данных (соответствующего самой длинной паре 
гипотеза / предпосылка). Этот процесс называется заполнением. Таким образом, каждый список идентификаторов будет иметь 
одинаковую длину, и BERT сможет принимать их в качестве входных данных. Это будет указанная выше переменная 
«ID входных слов» и наша первая входная переменная для модели BERT.

Однако нам также необходимо сообщить BERT, какие из идентификаторов в «идентификаторах входных слов» на самом деле 
принадлежат токенам, которые он должен встраивать, а какие из них следует игнорировать, потому что они просто 
заполняют. Именно здесь в игру вступают маски ввода: переменная маски ввода имеет тот же размер, что и переменная 
идентификаторов входных слов, но содержит 1 для каждой записи, которая является фактическим идентификатором токена (
который следует учитывать BERT), и 0 для каждой записи, которая является просто заполнение, которое BERT следует 
игнорировать. Это будет наш второй входной аргумент «маски ввода» для модели BERT.      

Наконец, BERT (но не RoBERTa, потому что он не был обучен предсказанию вероятности того, что предложение B 
принадлежит предложению A) также должен знать, какой из идентификаторов входных слов принадлежит какому предложению (
то есть гипотезе или посылке). Мы можем объяснить это BERT, используя упомянутую выше переменную 'идентификаторы 
входных типов'. Опять же, эта переменная имеет тот же размер, что и переменная идентификаторов входных слов, 
но на этот раз она содержит 1 для каждой записи, принадлежащей предложению B (т. Е. Посылке), и 0 для каждой записи, 
принадлежащей предложению A (т. Е. гипотеза), включая идентификатор нашего стартового токена для '[CLS]'. 
«Идентификаторы типа ввода» будут нашим третьим и последним входным аргументом для BERT. -      

Теперь мы собираемся закодировать все наши пары посылка / гипотеза для ввода в BERT.



Сначала скачиваем токенизатор.
- Сначала мы разделим наш текст на токены с помощью собственного токенизатора RoBERTa с использованием AutoTokenizer
и имени модели, чтобы токенизатор знал, как токенизировать. Это загрузит все необходимые файлы. Эта модель включает
более 100 языков, что полезно, поскольку наши данные также содержат несколько языков.

Сначала входные текстовые данные будут загружены в модель (после того, как они были преобразованы в токены), которая,
в свою очередь, выдает вложения слов. Преимущество по сравнению с другими типами вложений состоит в том, что вложения
 BERT (или вложения RoBERTa, потому что это та же самая архитектура) контекстуализированы. Прогнозы с
 контекстуализированными вложениями более точны, чем с неконтекстуализированными встраиваниями.

После того, как мы получим вложения для слов в нашем тексте от RoBERTa, мы можем ввести их в классификатор,
который затем, в свою очередь, вернет метки предсказания 0,1 или 2.

Для начала мы можем использовать предварительно обученную модель. Здесь мы будем использовать многоязычную модель
BERT от huggingface. Дополнительную информацию о BERT см. На странице
https://github.com/google-research/bert/blob/master/multilingual.md.